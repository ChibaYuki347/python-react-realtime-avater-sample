import React, { useState, useRef, useEffect } from 'react';
import * as speechSdk from 'microsoft-cognitiveservices-speech-sdk';
import { getTokenOrRefresh, getAvatarICEServerInfo, getAppConfig } from '../utils/speechUtils';
import { AvatarPlayerProps, AvatarSettings, AppConfig } from '../types';

const AvatarPlayer: React.FC<AvatarPlayerProps> = ({ 
  isConnected, 
  setIsConnected, 
  message, 
  setMessage,
  onSpeakWithAvatarReady
}) => {
    const [status, setStatus] = useState<string>('æº–å‚™ä¸­');
    const [error, setError] = useState<string | null>(null);
    const [isSpeaking, setIsSpeaking] = useState<boolean>(false);
    const [debugInfo, setDebugInfo] = useState<string[]>([]);
    const [connectionRetries, setConnectionRetries] = useState<number>(0);
    const [appConfig, setAppConfig] = useState<AppConfig | null>(null);
    const [avatarSettings, setAvatarSettings] = useState<AvatarSettings>({
        voiceName: 'ja-JP-NanamiNeural',
        voiceLanguage: 'ja-JP',
        avatarCharacter: 'lisa',
        avatarStyle: 'casual-sitting',
        videoFormat: 'mp4',
        region: 'eastus',
        availableCustomVoices: [],
        customAvatarEnabled: false,
        customVoiceEnabled: false,
        customVoiceDeploymentId: ''
    });
    
    // refs with proper typing
    const videoRef = useRef<HTMLVideoElement>(null);
    const audioRef = useRef<HTMLAudioElement>(null);
    const peerConnectionRef = useRef<RTCPeerConnection | null>(null);
    const avatarSynthesizerRef = useRef<speechSdk.AvatarSynthesizer | null>(null);
    const speechConfigRef = useRef<speechSdk.SpeechConfig | null>(null);

    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¿½åŠ ã™ã‚‹é–¢æ•°
    const addDebugInfo = (info: string) => {
        const timestamp = new Date().toLocaleTimeString();
        const debugMessage = `[${timestamp}] ${info}`;
        console.log(debugMessage);
        setDebugInfo(prev => [...prev.slice(-9), debugMessage]); // æœ€æ–°10ä»¶ã‚’ä¿æŒ
    };

    useEffect(() => {
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’èª­ã¿è¾¼ã¿
        const loadConfig = async () => {
            try {
                const config = await getAppConfig();
                setAppConfig(config); // è¨­å®šã‚’ä¿å­˜
                
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒœã‚¤ã‚¹ã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹ã‚’é¸æŠ
                const selectedVoiceName = config.voice.defaultName;
                
                // ã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã€ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆIDã‚’å–å¾—
                const isCustomVoice = config.availableCustomVoices?.includes(selectedVoiceName) || false;
                const deploymentId = isCustomVoice ? config.customVoiceDeploymentIds?.[selectedVoiceName] || '' : '';
                
                setAvatarSettings({
                    voiceName: selectedVoiceName,
                    voiceLanguage: config.voice.defaultLanguage,
                    avatarCharacter: config.avatar.defaultCharacter,
                    avatarStyle: config.avatar.defaultStyle,
                    videoFormat: config.avatar.defaultVideoFormat,
                    region: config.region,
                    availableCustomVoices: config.availableCustomVoices || [],
                    customAvatarEnabled: config.customAvatar?.enabled || false,
                    customVoiceEnabled: isCustomVoice,
                    customVoiceDeploymentId: deploymentId
                });
                addDebugInfo(`è¨­å®šèª­ã¿è¾¼ã¿å®Œäº†: voice=${selectedVoiceName}, isCustomVoice=${isCustomVoice}, deploymentId=${deploymentId}, avatar=${config.avatar.defaultCharacter}`);
            } catch (error) {
                console.error('è¨­å®šèª­ã¿è¾¼ã¿å¤±æ•—:', error);
                addDebugInfo(`è¨­å®šèª­ã¿è¾¼ã¿å¤±æ•—: ${error}`);
            }
        };
        
        loadConfig();
        
        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        return () => {
            addDebugInfo("ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹");
            if (avatarSynthesizerRef.current) {
                avatarSynthesizerRef.current.close();
            }
            if (peerConnectionRef.current) {
                peerConnectionRef.current.close();
            }
        };
    }, []);

    // è‡ªå‹•èª­ã¿ä¸Šã’é–¢æ•°ã‚’è¦ªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ç™»éŒ²
    useEffect(() => {
        if (onSpeakWithAvatarReady) {
            onSpeakWithAvatarReady(speakTextAuto);
        }
    }, [onSpeakWithAvatarReady, isConnected]);

    /**
     * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®è©³ç´°æƒ…å ±ã‚’å–å¾—
     */
    const getStreamInfo = (stream: MediaStream): string => {
        const videoTracks = stream.getVideoTracks();
        const audioTracks = stream.getAudioTracks();
        return `Video tracks: ${videoTracks.length} (enabled: ${videoTracks.filter(t => t.enabled).length}), Audio tracks: ${audioTracks.length} (enabled: ${audioTracks.filter(t => t.enabled).length})`;
    };

    /**
     * WebRTCæ¥ç¶šã®å†è©¦è¡Œæ©Ÿèƒ½
     */
    const retryConnection = async (authToken: string, region: string): Promise<void> => {
        const maxRetries = 3;
        
        if (connectionRetries >= maxRetries) {
            throw new Error(`æ¥ç¶šè©¦è¡Œå›æ•°ãŒä¸Šé™(${maxRetries}å›)ã«é”ã—ã¾ã—ãŸ`);
        }

        addDebugInfo(`æ¥ç¶šå†è©¦è¡Œ ${connectionRetries + 1}/${maxRetries}`);
        setConnectionRetries(prev => prev + 1);
        
        // å°‘ã—å¾…æ©Ÿã—ã¦ã‹ã‚‰å†è©¦è¡Œ
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        return initializeAvatarInternal(authToken, region, true);
    };

    /**
     * ã‚¢ãƒã‚¿ãƒ¼æ¥ç¶šã®å†…éƒ¨å®Ÿè£…
     */
    const initializeAvatarInternal = async (authToken: string, region: string, isRetry: boolean = false): Promise<void> => {
        if (!isRetry) {
            setConnectionRetries(0);
        }

        setStatus('Speech Configã‚’è¨­å®šä¸­...');
        
        // Speech Configã‚’ä½œæˆ
        const speechConfig = speechSdk.SpeechConfig.fromAuthorizationToken(authToken, region);
        speechConfig.speechSynthesisLanguage = avatarSettings.voiceLanguage;
        speechConfig.speechSynthesisVoiceName = avatarSettings.voiceName;
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹ä½¿ç”¨æ™‚ã®è¨­å®š
        if (avatarSettings.customVoiceEnabled && avatarSettings.customVoiceDeploymentId) {
            // ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆIDã‚’è¨­å®š
            (speechConfig as any).endpointId = avatarSettings.customVoiceDeploymentId;
            addDebugInfo(`ã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆIDè¨­å®š: ${avatarSettings.customVoiceDeploymentId}`);
        }
        
        speechConfigRef.current = speechConfig;
        addDebugInfo(`Speech Configä½œæˆå®Œäº†: lang=${speechConfig.speechSynthesisLanguage}, voice=${speechConfig.speechSynthesisVoiceName}, customVoice=${avatarSettings.customVoiceEnabled}`);

        setStatus('ã‚¢ãƒã‚¿ãƒ¼è¨­å®šä¸­...');
        
        // ã‚¢ãƒã‚¿ãƒ¼è¨­å®šã‚’ä½œæˆ
        const avatarConfig = new speechSdk.AvatarConfig(
            avatarSettings.avatarCharacter, // ã‚¢ãƒã‚¿ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
            avatarSettings.avatarStyle, // ã‚¢ãƒã‚¿ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«
            avatarSettings.videoFormat as any // ãƒ“ãƒ‡ã‚ªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆå‹å®šç¾©ã®å•é¡Œã‚’å›é¿ï¼‰
        );
        
        // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒã‚¿ãƒ¼ã®å ´åˆã¯customizedã‚’trueã«è¨­å®š
        if (avatarSettings.customAvatarEnabled) {
            (avatarConfig as any).customized = true;
            
            // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒã‚¿ãƒ¼ä½¿ç”¨æ™‚ã€ã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹ã‚’ä½¿ã†å ´åˆã¯useBuiltInVoiceã‚’falseã«è¨­å®š
            if (avatarSettings.customVoiceEnabled) {
                (avatarConfig as any).useBuiltInVoice = false;
                addDebugInfo(`useBuiltInVoiceè¨­å®š: falseï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹ä½¿ç”¨ï¼‰`);
            } else {
                (avatarConfig as any).useBuiltInVoice = true;
                addDebugInfo(`useBuiltInVoiceè¨­å®š: trueï¼ˆVoice Sync for Avatarä½¿ç”¨ï¼‰`);
            }
        }
        
        addDebugInfo(`ã‚¢ãƒã‚¿ãƒ¼è¨­å®šä½œæˆå®Œäº†: character=${avatarSettings.avatarCharacter}, style=${avatarSettings.avatarStyle}, customized=${avatarSettings.customAvatarEnabled}`);

        setStatus('ICEã‚µãƒ¼ãƒãƒ¼æƒ…å ±å–å¾—ä¸­...');
        
        // Azureå°‚ç”¨ã®ICEã‚µãƒ¼ãƒãƒ¼æƒ…å ±ã‚’å–å¾—
        let iceServers: RTCIceServer[];
        try {
            iceServers = await getAvatarICEServerInfo(region, authToken);
            addDebugInfo(`Azure ICEã‚µãƒ¼ãƒãƒ¼æƒ…å ±å–å¾—æˆåŠŸ: ${iceServers.length}å€‹ã®ã‚µãƒ¼ãƒãƒ¼`);
            console.log('ICE servers for RTCPeerConnection:', iceServers);
            
            // å„ã‚µãƒ¼ãƒãƒ¼ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
            iceServers.forEach((server, index) => {
                console.log(`ICE Server ${index}:`, server);
                addDebugInfo(`Server ${index}: urls=${Array.isArray(server.urls) ? server.urls.join(',') : server.urls}, username=${server.username || 'ãªã—'}`);
            });
        } catch (error) {
            addDebugInfo(`Azure ICEã‚µãƒ¼ãƒãƒ¼å–å¾—å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨: ${error}`);
            iceServers = [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ];
        }

        setStatus('WebRTCæ¥ç¶šã‚’ä½œæˆä¸­...');
        
        // WebRTCãƒ”ã‚¢æ¥ç¶šã‚’ä½œæˆ
        let peerConnection: RTCPeerConnection;
        try {
            const config: RTCConfiguration = {
                iceServers: iceServers,
                iceTransportPolicy: 'all',
                bundlePolicy: 'balanced',
                iceCandidatePoolSize: 10, // ICEå€™è£œãƒ—ãƒ¼ãƒ«ã‚µã‚¤ã‚ºã‚’å¢—ã‚„ã—ã¦æ¥ç¶šæˆåŠŸç‡å‘ä¸Š
                rtcpMuxPolicy: 'require'   // RTCPå¤šé‡åŒ–ã‚’å¿…é ˆã«ã—ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
            };
            
            console.log('Creating RTCPeerConnection with config:', config);
            addDebugInfo(`RTCPeerConnectionè¨­å®š: ${JSON.stringify(config, null, 2)}`);
            
            peerConnection = new RTCPeerConnection(config);
            peerConnectionRef.current = peerConnection;
            addDebugInfo("WebRTC PeerConnectionä½œæˆå®Œäº†");
        } catch (peerError) {
            console.error('RTCPeerConnectionä½œæˆã‚¨ãƒ©ãƒ¼:', peerError);
            addDebugInfo(`RTCPeerConnectionä½œæˆå¤±æ•—: ${peerError}`);
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªSTUNã‚µãƒ¼ãƒãƒ¼ã§å†è©¦è¡Œ
            addDebugInfo("åŸºæœ¬STUNã‚µãƒ¼ãƒãƒ¼ã§å†è©¦è¡Œä¸­...");
            const fallbackConfig: RTCConfiguration = {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                iceTransportPolicy: 'all',
                bundlePolicy: 'balanced'
            };
            
            peerConnection = new RTCPeerConnection(fallbackConfig);
            peerConnectionRef.current = peerConnection;
            addDebugInfo("WebRTC PeerConnection (ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯) ä½œæˆå®Œäº†");
        }

        // ICEæ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–ã¨ãƒªã‚¹ã‚¿ãƒ¼ãƒˆæ©Ÿèƒ½
        let iceRestartTimer: NodeJS.Timeout;
        
        peerConnection.oniceconnectionstatechange = () => {
            addDebugInfo(`ICEæ¥ç¶šçŠ¶æ…‹: ${peerConnection.iceConnectionState}`);
            
            if (peerConnection.iceConnectionState === 'disconnected') {
                addDebugInfo("ICEæ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã‚’è©¦è¡Œã—ã¾ã™...");
                
                // 10ç§’å¾Œã«ICEãƒªã‚¹ã‚¿ãƒ¼ãƒˆã‚’å®Ÿè¡Œ
                iceRestartTimer = setTimeout(async () => {
                    try {
                        addDebugInfo("ICEæ¥ç¶šã‚’ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ã„ã¾ã™...");
                        
                        // ICEãƒªã‚¹ã‚¿ãƒ¼ãƒˆã®ãŸã‚ã®offer/answeräº¤æ›
                        const offer = await peerConnection.createOffer({ iceRestart: true });
                        await peerConnection.setLocalDescription(offer);
                        
                        // ã‚¢ãƒã‚¿ãƒ¼ã‚·ãƒ³ã‚»ã‚µã‚¤ã‚¶ãƒ¼ã«æ–°ã—ã„offerã‚’é€ä¿¡
                        if (avatarSynthesizerRef.current) {
                            await avatarSynthesizerRef.current.startAvatarAsync(peerConnection);
                            addDebugInfo("ICEãƒªã‚¹ã‚¿ãƒ¼ãƒˆå®Œäº†");
                        }
                    } catch (error) {
                        addDebugInfo(`ICEãƒªã‚¹ã‚¿ãƒ¼ãƒˆå¤±æ•—: ${error}`);
                        console.error('ICE restart failed:', error);
                    }
                }, 10000);
            }
            
            if (peerConnection.iceConnectionState === 'connected' || 
                peerConnection.iceConnectionState === 'completed') {
                addDebugInfo("ICEæ¥ç¶šãŒå¾©æ—§ã—ã¾ã—ãŸ");
                if (iceRestartTimer) {
                    clearTimeout(iceRestartTimer);
                }
            }
            
            // æ¥ç¶šå¤±æ•—æ™‚ã®å†è©¦è¡Œãƒ­ã‚¸ãƒƒã‚¯
            if (peerConnection.iceConnectionState === 'failed' && !isRetry) {
                addDebugInfo("ICEæ¥ç¶šå¤±æ•—ã€å†è©¦è¡Œã‚’é–‹å§‹");
                if (iceRestartTimer) {
                    clearTimeout(iceRestartTimer);
                }
                
                setTimeout(() => {
                    retryConnection(authToken, region).catch(error => {
                        addDebugInfo(`å†è©¦è¡Œã‚‚å¤±æ•—: ${error.message}`);
                        setError(error.message);
                        setIsConnected(false);
                    });
                }, 1000);
            }
        };

        // æ¥ç¶šçŠ¶æ…‹ã®ç›£è¦–ã¨è©³ç´°è¨ºæ–­
        peerConnection.onconnectionstatechange = () => {
            addDebugInfo(`æ¥ç¶šçŠ¶æ…‹: ${peerConnection.connectionState}`);
            
            if (peerConnection.connectionState === 'connected') {
                addDebugInfo("WebRTCæ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¾ã—ãŸ");
                setConnectionRetries(0); // æˆåŠŸæ™‚ã¯ãƒªã‚»ãƒƒãƒˆ
            } else if (peerConnection.connectionState === 'failed') {
                addDebugInfo("WebRTCæ¥ç¶šãŒå®Œå…¨ã«å¤±æ•—ã—ã¾ã—ãŸ");
                
                // æ¥ç¶šå¤±æ•—æ™‚ã®è¨ºæ–­æƒ…å ±ã‚’åé›†
                const stats = {
                    iceConnectionState: peerConnection.iceConnectionState,
                    connectionState: peerConnection.connectionState,
                    signalingState: peerConnection.signalingState,
                    iceGatheringState: peerConnection.iceGatheringState
                };
                
                addDebugInfo(`è¨ºæ–­æƒ…å ±: ${JSON.stringify(stats)}`);
                console.error('WebRTC connection failed with stats:', stats);
            }
        };

        // ICEå€™è£œã®è©³ç´°ç›£è¦–
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                const candidate = event.candidate;
                addDebugInfo(`ICEå€™è£œ: ${candidate.type} ${candidate.protocol} ${candidate.address || 'hidden'} priority=${candidate.priority}`);
            } else {
                addDebugInfo("ICEå€™è£œåé›†å®Œäº†");
            }
        };
        
        // ICEåé›†çŠ¶æ…‹ã®ç›£è¦–
        peerConnection.onicegatheringstatechange = () => {
            addDebugInfo(`ICEåé›†çŠ¶æ…‹: ${peerConnection.iceGatheringState}`);
        };

        // ontrackã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’è¨­å®š
        peerConnection.ontrack = (event: RTCTrackEvent) => {
            addDebugInfo(`Trackå—ä¿¡: ${event.track.kind}, readyState: ${event.track.readyState}`);
            const stream = event.streams[0];
            addDebugInfo(`Streamæƒ…å ±: ${getStreamInfo(stream)}`);

            if (event.track.kind === 'video') {
                if (videoRef.current) {
                    videoRef.current.srcObject = stream;
                    videoRef.current.autoplay = true;
                    videoRef.current.muted = true; // autoplayã®ãŸã‚
                    videoRef.current.playsInline = true;
                    
                    // ãƒ“ãƒ‡ã‚ªã®èª­ã¿è¾¼ã¿çŠ¶æ…‹ã‚’ç›£è¦–
                    videoRef.current.onloadedmetadata = () => {
                        addDebugInfo(`ãƒ“ãƒ‡ã‚ªãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†: ${videoRef.current?.videoWidth}x${videoRef.current?.videoHeight}`);
                    };
                    
                    videoRef.current.oncanplay = () => {
                        addDebugInfo("ãƒ“ãƒ‡ã‚ªå†ç”Ÿå¯èƒ½");
                    };
                    
                    videoRef.current.onplay = () => {
                        addDebugInfo("ãƒ“ãƒ‡ã‚ªå†ç”Ÿé–‹å§‹");
                    };
                    
                    videoRef.current.onerror = (e) => {
                        addDebugInfo(`ãƒ“ãƒ‡ã‚ªã‚¨ãƒ©ãƒ¼: ${e}`);
                    };

                    // æ‰‹å‹•ã§å†ç”Ÿã‚’è©¦è¡Œ
                    setTimeout(() => {
                        if (videoRef.current) {
                            videoRef.current.play().then(() => {
                                addDebugInfo("ãƒ“ãƒ‡ã‚ªæ‰‹å‹•å†ç”ŸæˆåŠŸ");
                            }).catch((e) => {
                                addDebugInfo(`ãƒ“ãƒ‡ã‚ªæ‰‹å‹•å†ç”Ÿå¤±æ•—: ${e.message}`);
                            });
                        }
                    }, 1000);
                }
            }
            
            if (event.track.kind === 'audio') {
                if (audioRef.current) {
                    audioRef.current.srcObject = stream;
                    audioRef.current.autoplay = true;
                    
                    // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®çŠ¶æ…‹ã‚’ç›£è¦–
                    audioRef.current.oncanplay = () => {
                        addDebugInfo("ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå†ç”Ÿå¯èƒ½");
                    };
                    
                    audioRef.current.onplay = () => {
                        addDebugInfo("ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå†ç”Ÿé–‹å§‹");
                    };
                    
                    audioRef.current.onerror = (e) => {
                        addDebugInfo(`ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚¨ãƒ©ãƒ¼: ${e}`);
                    };

                    // æ‰‹å‹•ã§å†ç”Ÿã‚’è©¦è¡Œ
                    setTimeout(() => {
                        if (audioRef.current) {
                            audioRef.current.play().then(() => {
                                addDebugInfo("ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªæ‰‹å‹•å†ç”ŸæˆåŠŸ");
                            }).catch((e) => {
                                addDebugInfo(`ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªæ‰‹å‹•å†ç”Ÿå¤±æ•—: ${e.message}`);
                            });
                        }
                    }, 1000);
                }
            }
        };

        // ãƒˆãƒ©ãƒ³ã‚·ãƒ¼ãƒãƒ¼ã‚’è¿½åŠ 
        peerConnection.addTransceiver('video', { direction: 'sendrecv' });
        peerConnection.addTransceiver('audio', { direction: 'sendrecv' });
        addDebugInfo("ãƒˆãƒ©ãƒ³ã‚·ãƒ¼ãƒãƒ¼è¿½åŠ å®Œäº†");

        setStatus('ã‚¢ãƒã‚¿ãƒ¼ã‚·ãƒ³ã‚»ã‚µã‚¤ã‚¶ãƒ¼ã‚’ä½œæˆä¸­...');
        
        // ã‚¢ãƒã‚¿ãƒ¼ã‚·ãƒ³ã‚»ã‚µã‚¤ã‚¶ãƒ¼ã‚’ä½œæˆ
        const avatarSynthesizer = new speechSdk.AvatarSynthesizer(speechConfig, avatarConfig);
        
        avatarSynthesizerRef.current = avatarSynthesizer;
        addDebugInfo("AvatarSynthesizerä½œæˆå®Œäº†");

        setStatus('ã‚¢ãƒã‚¿ãƒ¼ã«æ¥ç¶šä¸­...');
        
        // ã‚¢ãƒã‚¿ãƒ¼ã‚’é–‹å§‹
        await avatarSynthesizer.startAvatarAsync(peerConnection);
        addDebugInfo("Avataræ¥ç¶šå®Œäº†");
        
        setStatus('æ¥ç¶šå®Œäº†');
        setIsConnected(true);
    };

    /**
     * ã‚¢ãƒã‚¿ãƒ¼æ¥ç¶šã‚’åˆæœŸåŒ–ã™ã‚‹é–¢æ•°
     */
    const initializeAvatar = async (): Promise<void> => {
        try {
            setError(null);
            setDebugInfo([]);
            setStatus('ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ä¸­...');
            addDebugInfo("ã‚¢ãƒã‚¿ãƒ¼åˆæœŸåŒ–é–‹å§‹");
            
            // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
            const { authToken, region, error: tokenError } = await getTokenOrRefresh();
            if (tokenError || !authToken || !region) {
                throw new Error(`ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—ã‚¨ãƒ©ãƒ¼: ${tokenError}`);
            }
            addDebugInfo(`ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—æˆåŠŸ: region=${region}`);

            await initializeAvatarInternal(authToken, region);
        } catch (error) {
            console.error('ã‚¢ãƒã‚¿ãƒ¼åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            setError(errorMessage);
            addDebugInfo(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
            setStatus('æ¥ç¶šã‚¨ãƒ©ãƒ¼');
            setIsConnected(false);
        }
    };
    /**
     * å¤–éƒ¨ã‹ã‚‰ã®è‡ªå‹•éŸ³å£°åˆæˆç”¨é–¢æ•°
     */
    const speakTextAuto = async (textToSpeak: string): Promise<void> => {
        if (!textToSpeak.trim()) {
            console.warn('è‡ªå‹•èª­ã¿ä¸Šã’: ç©ºã®ãƒ†ã‚­ã‚¹ãƒˆã§ã™');
            return;
        }

        if (!isConnected || !avatarSynthesizerRef.current) {
            console.warn('è‡ªå‹•èª­ã¿ä¸Šã’: ã‚¢ãƒã‚¿ãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“');
            setError('ã‚¢ãƒã‚¿ãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“');
            return;
        }

        try {
            setIsSpeaking(true);
            setError(null);
            addDebugInfo(`è‡ªå‹•éŸ³å£°åˆæˆé–‹å§‹: "${textToSpeak}"`);
            
            // SSMLå½¢å¼ã§éŸ³å£°åˆæˆã‚’å®Ÿè¡Œ
            const ssml = `
            <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='${avatarSettings.voiceLanguage}'>
                <voice name='${avatarSettings.voiceName}'>
                    ${textToSpeak}
                </voice>
            </speak>`;

            // éŸ³å£°åˆæˆã‚’å®Ÿè¡Œ
            avatarSynthesizerRef.current.speakSsmlAsync(ssml);
            addDebugInfo("è‡ªå‹•éŸ³å£°åˆæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡å®Œäº†");

        } catch (error) {
            console.error('è‡ªå‹•éŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            setError(errorMessage);
            addDebugInfo(`è‡ªå‹•éŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
        } finally {
            setTimeout(() => setIsSpeaking(false), 100); // ã‚ãšã‹ã«é…å»¶ã•ã›ã¦çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        }
    };

    /**
     * éŸ³å£°åˆæˆã¨ã‚¢ãƒã‚¿ãƒ¼è¡¨ç¤ºã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
     */
    const speakText = async (): Promise<void> => {
        if (!message.trim()) {
            setError('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
            return;
        }

        if (!isConnected || !avatarSynthesizerRef.current) {
            setError('ã‚¢ãƒã‚¿ãƒ¼ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“');
            return;
        }

        try {
            setIsSpeaking(true);
            setError(null);
            addDebugInfo(`éŸ³å£°åˆæˆé–‹å§‹: "${message}"`);
            
            // SSMLå½¢å¼ã§éŸ³å£°åˆæˆã‚’å®Ÿè¡Œ
            const ssml = `
            <speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='${avatarSettings.voiceLanguage}'>
                <voice name='${avatarSettings.voiceName}'>
                    ${message}
                </voice>
            </speak>`;

            // éŸ³å£°åˆæˆã‚’å®Ÿè¡Œ
            avatarSynthesizerRef.current.speakSsmlAsync(ssml);
            addDebugInfo("éŸ³å£°åˆæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡å®Œäº†");

        } catch (error) {
            console.error('éŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            setError(errorMessage);
            addDebugInfo(`éŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
        } finally {
            setIsSpeaking(false);
        }
    };

    /**
     * ã‚¢ãƒã‚¿ãƒ¼æ¥ç¶šã‚’åˆ‡æ–­ã™ã‚‹é–¢æ•°
     */
    const disconnectAvatar = (): void => {
        addDebugInfo("åˆ‡æ–­å‡¦ç†é–‹å§‹");
        
        if (avatarSynthesizerRef.current) {
            avatarSynthesizerRef.current.close();
            avatarSynthesizerRef.current = null;
            addDebugInfo("AvatarSynthesizeråˆ‡æ–­å®Œäº†");
        }

        if (peerConnectionRef.current) {
            peerConnectionRef.current.close();
            peerConnectionRef.current = null;
            addDebugInfo("PeerConnectionåˆ‡æ–­å®Œäº†");
        }

        // ãƒ¡ãƒ‡ã‚£ã‚¢è¦ç´ ã®srcObjectã‚’ã‚¯ãƒªã‚¢
        if (videoRef.current) {
            videoRef.current.srcObject = null;
        }
        if (audioRef.current) {
            audioRef.current.srcObject = null;
        }

        setIsConnected(false);
        setStatus('åˆ‡æ–­ã—ã¾ã—ãŸ');
        setConnectionRetries(0);
        addDebugInfo("åˆ‡æ–­å‡¦ç†å®Œäº†");
    };

    /**
     * ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹é–¢æ•°
     */
    const clearDebugInfo = (): void => {
        setDebugInfo([]);
        setError(null);
    };

    return (
        <div className="avatar-player-container">
            
            {/* ãƒ¡ã‚¤ãƒ³è¡¨ç¤ºã‚¨ãƒªã‚¢ - ã‚¢ãƒã‚¿ãƒ¼ãƒ“ãƒ‡ã‚ªã‚’æœ€åˆã«é…ç½® */}
            <div className="avatar-display">
                <video 
                    ref={videoRef}
                    className="avatar-video"
                    controls={false}
                    autoPlay
                    playsInline
                    muted
                    style={{
                        width: '100%',
                        maxWidth: '640px',
                        height: '360px',
                        backgroundColor: '#000',
                        border: '1px solid #ccc',
                        borderRadius: '8px'
                    }}
                />
                
                <audio ref={audioRef} style={{ display: 'none' }} />

                {/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */}
                <div style={{ 
                    marginTop: '15px', 
                    textAlign: 'center',
                    padding: '10px',
                    backgroundColor: '#f8f9fa',
                    borderRadius: '4px',
                    border: '1px solid #dee2e6'
                }}>
                    <div style={{ 
                        display: 'flex', 
                        justifyContent: 'space-between', 
                        alignItems: 'center',
                        marginBottom: '5px'
                    }}>
                        <span><strong>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:</strong> {status}</span>
                        <span style={{ color: isSpeaking ? '#28a745' : '#6c757d' }}>
                            {isSpeaking ? 'ğŸ”Š è©±ã—ã¦ã„ã‚‹' : 'ğŸ”‡ å¾…æ©Ÿä¸­'}
                        </span>
                    </div>
                    <div style={{ fontSize: '12px', color: '#6c757d' }}>
                        æ¥ç¶šå†è©¦è¡Œå›æ•°: {connectionRetries}å›
                    </div>
                    
                    {/* ã‚¨ãƒ©ãƒ¼è¡¨ç¤º */}
                    {error && (
                        <div style={{
                            marginTop: '10px',
                            padding: '10px',
                            backgroundColor: '#f8d7da',
                            border: '1px solid #f5c6cb',
                            borderRadius: '4px',
                            color: '#721c24',
                            fontSize: '14px'
                        }}>
                            ã‚¨ãƒ©ãƒ¼: {error}
                        </div>
                    )}
                </div>

                {/* ã‚¢ãƒã‚¿ãƒ¼æ¥ç¶šãƒ»åˆ‡æ–­ãƒœã‚¿ãƒ³ */}
                <div style={{ marginTop: '15px', textAlign: 'center' }}>
                    {!isConnected ? (
                        <button 
                            onClick={connectAvatar}
                            style={{
                                backgroundColor: '#28a745',
                                color: 'white',
                                padding: '10px 20px',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '16px',
                                marginRight: '10px'
                            }}
                        >
                            ã‚¢ãƒã‚¿ãƒ¼ã«æ¥ç¶š
                        </button>
                    ) : null}
                </div>

                {/* éŸ³å£°å…¥åŠ›ã‚¨ãƒªã‚¢ */}
                {isConnected && (
                    <div style={{ 
                        marginTop: '20px',
                        padding: '15px',
                        backgroundColor: '#f8f9fa',
                        borderRadius: '8px',
                        border: '1px solid #dee2e6'
                    }}>
                        <h4 style={{ marginTop: '0', marginBottom: '15px' }}>éŸ³å£°å…¥åŠ›</h4>
                        
                        <div style={{ marginBottom: '15px' }}>
                            <textarea
                                value={message}
                                onChange={(e) => setMessage(e.target.value)}
                                placeholder="è©±ã•ã›ãŸã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
                                style={{
                                    width: '100%',
                                    maxWidth: '600px',
                                    height: '80px',
                                    padding: '10px',
                                    border: '1px solid #ccc',
                                    borderRadius: '4px',
                                    fontSize: '14px',
                                    resize: 'vertical'
                                }}
                            />
                        </div>
                        
                        <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
                            <button 
                                onClick={speakText}
                                disabled={isSpeaking || !message.trim()}
                                style={{
                                    backgroundColor: isSpeaking ? '#ccc' : '#2196F3',
                                    color: 'white',
                                    padding: '10px 20px',
                                    border: 'none',
                                    borderRadius: '4px',
                                    cursor: isSpeaking ? 'not-allowed' : 'pointer',
                                    fontSize: '16px'
                                }}
                            >
                                {isSpeaking ? 'è©±ã—ã¦ã„ã¾ã™...' : 'ã‚¢ãƒã‚¿ãƒ¼ã«è©±ã•ã›ã‚‹'}
                            </button>
                            
                            <button 
                                onClick={disconnectAvatar}
                                style={{
                                    backgroundColor: '#f44336',
                                    color: 'white',
                                    padding: '10px 20px',
                                    border: 'none',
                                    borderRadius: '4px',
                                    cursor: 'pointer',
                                    fontSize: '16px'
                                }}
                            >
                                æ¥ç¶šã‚’åˆ‡æ–­
                            </button>
                        </div>
                    </div>
                )}
            </div>

            {/* Settings Panel - ã‚¢ãƒã‚¿ãƒ¼è¡¨ç¤ºã®å¾Œã«é…ç½® */}
            <div className="settings-panel" style={{
                backgroundColor: '#f5f5f5',
                padding: '20px',
                marginBottom: '20px',
                borderRadius: '8px',
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
                gap: '15px'
            }}>
                <h3 style={{gridColumn: '1 / -1', margin: '0 0 15px 0'}}>è¨­å®š</h3>
                
                <div>
                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>éŸ³å£°å:</label>
                    <input
                        type="text"
                        value={avatarSettings.voiceName}
                        onChange={(e) => setAvatarSettings(prev => ({...prev, voiceName: e.target.value}))}
                        placeholder="ja-JP-NanamiNeural"
                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc'}}
                    />
                </div>
                
                <div>
                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>éŸ³å£°è¨€èª:</label>
                    <input
                        type="text"
                        value={avatarSettings.voiceLanguage}
                        onChange={(e) => setAvatarSettings(prev => ({...prev, voiceLanguage: e.target.value}))}
                        placeholder="ja-JP"
                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc'}}
                    />
                </div>
                
                <div>
                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>ã‚¢ãƒã‚¿ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼:</label>
                    <input
                        type="text"
                        value={avatarSettings.avatarCharacter}
                        onChange={(e) => setAvatarSettings(prev => ({...prev, avatarCharacter: e.target.value}))}
                        placeholder="lisa"
                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc'}}
                    />
                </div>
                
                <div>
                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>ã‚¢ãƒã‚¿ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ«:</label>
                    <input
                        type="text"
                        value={avatarSettings.avatarStyle}
                        onChange={(e) => setAvatarSettings(prev => ({...prev, avatarStyle: e.target.value}))}
                        placeholder="casual-sitting"
                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc'}}
                    />
                </div>
                
                <div>
                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>ãƒ“ãƒ‡ã‚ªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ:</label>
                    <select
                        value={avatarSettings.videoFormat}
                        onChange={(e) => setAvatarSettings(prev => ({...prev, videoFormat: e.target.value}))}
                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc'}}
                    >
                        <option value="mp4">MP4</option>
                        <option value="webm">WebM</option>
                    </select>
                </div>
                
                <div>
                    <label style={{display: 'block', marginBottom: '5px', fontWeight: 'bold'}}>ãƒªãƒ¼ã‚¸ãƒ§ãƒ³:</label>
                    <input
                        type="text"
                        value={avatarSettings.region}
                        onChange={(e) => setAvatarSettings(prev => ({...prev, region: e.target.value}))}
                        placeholder="eastus"
                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc'}}
                    />
                </div>
                
                {/* ã‚«ã‚¹ã‚¿ãƒ ãƒœã‚¤ã‚¹è¨­å®š */}
                <div style={{gridColumn: '1 / -1', borderTop: '1px solid #ddd', paddingTop: '15px', marginTop: '10px'}}>
                    <h4 style={{margin: '0 0 10px 0', fontWeight: 'bold'}}>åˆ©ç”¨å¯èƒ½ãªãƒœã‚¤ã‚¹</h4>
                    {avatarSettings.availableCustomVoices.length > 0 ? (
                        <div>
                            <label style={{display: 'block', marginBottom: '5px'}}>åˆ©ç”¨å¯èƒ½ãªãƒœã‚¤ã‚¹:</label>
                            <div style={{backgroundColor: '#f8f9fa', padding: '10px', borderRadius: '4px', border: '1px solid #dee2e6'}}>
                                {avatarSettings.availableCustomVoices.map((voiceName) => (
                                    <div key={voiceName} style={{
                                        display: 'flex', 
                                        justifyContent: 'space-between', 
                                        alignItems: 'center',
                                        marginBottom: '5px',
                                        padding: '5px',
                                        backgroundColor: voiceName === avatarSettings.voiceName ? '#e3f2fd' : 'transparent',
                                        borderRadius: '3px'
                                    }}>
                                        <span><strong>{voiceName}</strong></span>
                                        <button
                                            onClick={() => {
                                                const isCustomVoice = avatarSettings.availableCustomVoices.includes(voiceName);
                                                const deploymentId = isCustomVoice ? (appConfig?.customVoiceDeploymentIds?.[voiceName] || '') : '';
                                                setAvatarSettings(prev => ({
                                                    ...prev, 
                                                    voiceName,
                                                    customVoiceEnabled: isCustomVoice,
                                                    customVoiceDeploymentId: deploymentId
                                                }));
                                            }}
                                            style={{
                                                padding: '2px 8px',
                                                fontSize: '12px',
                                                backgroundColor: voiceName === avatarSettings.voiceName ? '#1976d2' : '#6c757d',
                                                color: 'white',
                                                border: 'none',
                                                borderRadius: '3px',
                                                cursor: 'pointer'
                                            }}
                                        >
                                            {voiceName === avatarSettings.voiceName ? 'é¸æŠä¸­' : 'é¸æŠ'}
                                        </button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ) : (
                        <div style={{color: '#6c757d', fontStyle: 'italic'}}>
                            åˆ©ç”¨å¯èƒ½ãªãƒœã‚¤ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç’°å¢ƒå¤‰æ•° AVAILABLE_CUSTOM_VOICES ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚<br/>
                            <strong>ä¾‹:</strong> CUSTOM_VOICES={`{"MyVoice1": "deployment-id-1", "MyVoice2": "deployment-id-2"}`}
                        </div>
                    )}
                </div>
                
                {/* ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒã‚¿ãƒ¼è¨­å®š */}
                <div style={{gridColumn: '1 / -1', borderTop: '1px solid #ddd', paddingTop: '15px', marginTop: '10px'}}>
                    <label style={{display: 'flex', alignItems: 'center', fontWeight: 'bold', marginBottom: '10px'}}>
                        <input
                            type="checkbox"
                            checked={avatarSettings.customAvatarEnabled}
                            onChange={(e) => setAvatarSettings(prev => ({...prev, customAvatarEnabled: e.target.checked}))}
                            style={{marginRight: '8px'}}
                        />
                        ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒã‚¿ãƒ¼ä½¿ç”¨
                    </label>
                    {avatarSettings.customAvatarEnabled && (
                        <div style={{marginLeft: '20px', color: '#666', fontSize: '14px'}}>
                            <p>â€» ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒã‚¿ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã‚¢ãƒã‚¿ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒã‚¿ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
                            <p>â€» ä¾‹: "YourCustomAvatarName"</p>
                        </div>
                    )}
                </div>
            </div>

            {/* ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚¨ãƒªã‚¢ */}
                <video 
                    ref={videoRef}
                    className="avatar-video"
                    controls={false}
                    autoPlay
                    playsInline
                    muted
                    style={{
                        width: '100%',
                        maxWidth: '640px',
                        height: '360px',
                        backgroundColor: '#000',
                        border: '1px solid #ccc',
                        borderRadius: '8px'
                    }}
                />
                <audio 
                    ref={audioRef}
                    autoPlay
                    style={{ display: 'none' }}
                />
            </div>

            {/* çŠ¶æ…‹è¡¨ç¤ºã‚¨ãƒªã‚¢ */}
            <div className="status-section">
                <h3>çŠ¶æ…‹: {status}</h3>
                <p>æ¥ç¶šçŠ¶æ³: {isConnected ? 'âœ… æ¥ç¶šæ¸ˆã¿' : 'âŒ æœªæ¥ç¶š'}</p>
                {connectionRetries > 0 && (
                    <p>å†è©¦è¡Œå›æ•°: {connectionRetries}/3</p>
                )}
                
                {error && (
                    <div className="error-message" style={{ 
                        backgroundColor: '#ffebee', 
                        color: '#c62828', 
                        padding: '10px', 
                        borderRadius: '4px', 
                        margin: '10px 0' 
                    }}>
                        ã‚¨ãƒ©ãƒ¼: {error}
                    </div>
                )}
            </div>

            {/* æ“ä½œãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */}
            <div className="control-section" style={{ margin: '20px 0' }}>
                {!isConnected ? (
                    <button 
                        onClick={initializeAvatar}
                        style={{
                            backgroundColor: '#4CAF50',
                            color: 'white',
                            padding: '10px 20px',
                            border: 'none',
                            borderRadius: '4px',
                            cursor: 'pointer',
                            fontSize: '16px'
                        }}
                    >
                        ã‚¢ãƒã‚¿ãƒ¼ã«æ¥ç¶š
                    </button>
                ) : (
                    <div>
                        <div style={{ margin: '10px 0' }}>
                            <textarea
                                value={message}
                                onChange={(e) => setMessage(e.target.value)}
                                placeholder="è©±ã•ã›ãŸã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
                                style={{
                                    width: '100%',
                                    maxWidth: '600px',
                                    height: '80px',
                                    padding: '10px',
                                    border: '1px solid #ccc',
                                    borderRadius: '4px',
                                    fontSize: '14px',
                                    resize: 'vertical'
                                }}
                            />
                        </div>
                        
                        <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
                            <button 
                                onClick={speakText}
                                disabled={isSpeaking || !message.trim()}
                                style={{
                                    backgroundColor: isSpeaking ? '#ccc' : '#2196F3',
                                    color: 'white',
                                    padding: '10px 20px',
                                    border: 'none',
                                    borderRadius: '4px',
                                    cursor: isSpeaking ? 'not-allowed' : 'pointer',
                                    fontSize: '16px'
                                }}
                            >
                                {isSpeaking ? 'è©±ã—ã¦ã„ã¾ã™...' : 'ã‚¢ãƒã‚¿ãƒ¼ã«è©±ã•ã›ã‚‹'}
                            </button>
                            
                            <button 
                                onClick={disconnectAvatar}
                                style={{
                                    backgroundColor: '#f44336',
                                    color: 'white',
                                    padding: '10px 20px',
                                    border: 'none',
                                    borderRadius: '4px',
                                    cursor: 'pointer',
                                    fontSize: '16px'
                                }}
                            >
                                æ¥ç¶šã‚’åˆ‡æ–­
                            </button>
                        </div>
                    </div>
                )}
            </div>

            {/* ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚¨ãƒªã‚¢ */}
            <div className="debug-section" style={{ 
                marginTop: '20px', 
                padding: '15px', 
                backgroundColor: '#f5f5f5', 
                borderRadius: '8px',
                fontSize: '12px',
                fontFamily: 'monospace'
            }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                    <h4 style={{ margin: '0' }}>ãƒ‡ãƒãƒƒã‚°æƒ…å ±</h4>
                    <button 
                        onClick={clearDebugInfo}
                        style={{
                            backgroundColor: '#9e9e9e',
                            color: 'white',
                            padding: '5px 10px',
                            border: 'none',
                            borderRadius: '3px',
                            cursor: 'pointer',
                            fontSize: '12px'
                        }}
                    >
                        ã‚¯ãƒªã‚¢
                    </button>
                </div>
                
                <div style={{ 
                    maxHeight: '200px', 
                    overflowY: 'auto', 
                    backgroundColor: 'white', 
                    padding: '10px', 
                    borderRadius: '4px',
                    border: '1px solid #ddd'
                }}>
                    {debugInfo.length === 0 ? (
                        <p style={{ color: '#666', margin: '0' }}>ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>
                    ) : (
                        debugInfo.map((info, index) => (
                            <div key={index} style={{ margin: '2px 0', lineHeight: '1.4' }}>
                                {info}
                            </div>
                        ))
                    )}
                </div>
            </div>
        </div>
    );
};

export default AvatarPlayer;